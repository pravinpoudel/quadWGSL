{"version":3,"sources":["force_directed.ts"],"names":["wgsl_1","require","ForceDirected","device","this","coolingFactor","iterationCount","threshold","force","nodeDataBuffer","createBuffer","size","usage","GPUBufferUsage","STORAGE","COPY_DST","edgeDataBuffer","adjMatrixBuffer","forceDataBuffer","COPY_SRC","treeBuffer","lastIndexBuffer","mappedAtCreation","Int32Array","getMappedRange","set","unmap","uniformParameterBuffer","UNIFORM","createAdjMatrixPipeline","createComputePipeline","compute","module","createShaderModule","code","create_adjacency_matrix","entryPoint","bindGroupLayoutTree","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","type","treePipelineLayout","createPipelineLayout","bindGroupLayouts","computeTreePipeline","layout","buildTree","computeForcesPipeline","compute_forces_combined","computeAttractForcesPipeline","compute_forces_a","applyForcesPipeline","apply_forces","paramsBuffer","prototype","runForces","nodeLength","edgeLength","l","iterRef","console","log","upload","mapping","Uint32Array","Float32Array","arrInstance","Uint8Array","commandEncoder","createCommandEncoder","copyBufferToBuffer","createBindGroup","getBindGroupLayout","resource","pass","beginComputePass","setBindGroup","setPipeline","dispatch","endPass","queue","submit","finish","iterationTimes","totalStart","performance","now","applyBindGroup","bindGroupTree","treeComputePass","gpuReadTreeBuffer","MAP_READ","mapAsync","GPUMapMode","READ","_a","sent","arrayBuffer","resultTree","bindGroup","start","onSubmittedWorkDone","end","push","totalEnd","iterAvg","reduce","a","b","length","current","innerText","exports"],"mappings":"y7CAEA,IAAAA,OAAAC,QAAA,UASAC,cAAA,WAyBE,SAAAA,EAAYC,GAhBLC,KAAAC,cAAwB,GAYxBD,KAAAE,eAAyB,IACzBF,KAAAG,UAAoB,IACpBH,KAAAI,MAAgB,IAGrBJ,KAAKD,OAASA,EAEdC,KAAKK,eAAiBL,KAAKD,OAAOO,aAAa,CAC7CC,KAAM,GACNC,MAAOC,eAAeC,QAAUD,eAAeE,WAGjDX,KAAKY,eAAiBZ,KAAKD,OAAOO,aAAa,CAC7CC,KAAM,GACNC,MAAOC,eAAeC,QAAUD,eAAeE,WAGjDX,KAAKa,gBAAkBb,KAAKD,OAAOO,aAAa,CAC9CC,KAAM,GACNC,MAAOC,eAAeC,QAAUD,eAAeE,WAGjDX,KAAKc,gBAAkBd,KAAKD,OAAOO,aAAa,CAC9CC,KAAM,GACNC,MAAOC,eAAeC,QAAUD,eAAeM,WAGjDf,KAAKgB,WAAahB,KAAKD,OAAOO,aAAa,CACzCC,KAAM,GACNC,MAAOC,eAAeC,QAAUD,eAAeM,WAGjDf,KAAKiB,gBAAkBjB,KAAKD,OAAOO,aAAa,CAC9CC,KAAM,EACNW,kBAAkB,EAClBV,MAAOC,eAAeC,QAAUD,eAAeM,WAGjD,IAAII,WAAWnB,KAAKiB,gBAAgBG,kBAAkBC,IAAI,CAAC,IAC3DrB,KAAKiB,gBAAgBK,QAErBtB,KAAKuB,uBAAyBvB,KAAKD,OAAOO,aAAa,CACrDC,KAAM,GACNC,MAAOC,eAAee,QAAUf,eAAeE,WAGjDX,KAAKyB,wBAA0B1B,EAAO2B,sBAAsB,CAC1DC,QAAS,CACPC,OAAQ7B,EAAO8B,mBAAmB,CAChCC,KAAMlC,OAAAmC,0BAERC,WAAY,UAIhBhC,KAAKiC,oBAAsBlC,EAAOmC,sBAAsB,CACtDC,QAAS,CACP,CAEEC,QAAS,EACTC,WAAYC,eAAeC,QAC3BC,OAAQ,CACNC,KAAM,sBAGV,CAEEL,QAAS,EACTC,WAAYC,eAAeC,QAC3BC,OAAQ,CACNC,KAAM,YAGV,CAEEL,QAAS,EACTC,WAAYC,eAAeC,QAC3BC,OAAQ,CACNC,KAAM,YAIV,CACEL,QAAS,EACTC,WAAYC,eAAeC,QAC3BC,OAAQ,CACNC,KAAM,eAMdzC,KAAK0C,mBAAqB1C,KAAKD,OAAO4C,qBAAqB,CACzDC,iBAAkB,CAAC5C,KAAKiC,uBAG1BjC,KAAK6C,oBAAsB9C,EAAO2B,sBAAsB,CACtDoB,OAAQ9C,KAAK0C,mBACbf,QAAS,CACPC,OAAQ7B,EAAO8B,mBAAmB,CAChCC,KAAMlC,OAAAmD,YAERf,WAAY,UAIhBhC,KAAKgD,sBAAwBjD,EAAO2B,sBAAsB,CACxDC,QAAS,CACPC,OAAQ7B,EAAO8B,mBAAmB,CAChCC,KAAMlC,OAAAqD,0BAERjB,WAAY,UAIhBhC,KAAKkD,6BAA+BnD,EAAO2B,sBAAsB,CAC/DC,QAAS,CACPC,OAAQ7B,EAAO8B,mBAAmB,CAChCC,KAAMlC,OAAAuD,mBAERnB,WAAY,QAEdc,OAAQ/C,EAAO4C,qBAAqB,CAClCC,iBAAkB,CAChB7C,EAAOmC,sBAAsB,CAC3BC,QAAS,CACP,CACEC,QAAS,EACTC,WAAYC,eAAeC,QAC3BC,OAAQ,CACNC,KAAM,sBAGV,CACEL,QAAS,EACTC,WAAYC,eAAeC,QAC3BC,OAAQ,CACNC,KAAM,sBAGV,CACEL,QAAS,EACTC,WAAYC,eAAeC,QAC3BC,OAAQ,CACNC,KAAM,YAGV,CACEL,QAAS,EACTC,WAAYC,eAAeC,QAC3BC,OAAQ,CACNC,KAAM,oBASpBzC,KAAKoD,oBAAsBrD,EAAO2B,sBAAsB,CACtDC,QAAS,CACPC,OAAQ7B,EAAO8B,mBAAmB,CAChCC,KAAMlC,OAAAyD,eAERrB,WAAY,UAKhBhC,KAAKsD,aAAevD,EAAOO,aAAa,CACtCC,KAAM,GACNC,MAAOC,eAAee,QAAUf,eAAeE,WAiWrD,OA7VQb,EAAAyD,UAAAC,UAAN,SACEnD,EACAO,EACA6C,EACAC,EACAzD,EACA0D,EACAzD,EACAC,EACAyD,eARA,IAAAvD,IAAAA,EAAiBL,KAAKK,qBACtB,IAAAO,IAAAA,EAAiBZ,KAAKY,qBACtB,IAAA6C,IAAAA,EAAA,QACA,IAAAC,IAAAA,EAAA,QACA,IAAAzD,IAAAA,EAAgBD,KAAKC,oBACrB,IAAA0D,IAAAA,EAAA,UACA,IAAAzD,IAAAA,EAAiBF,KAAKE,qBACtB,IAAAC,IAAAA,EAAYH,KAAKG,wJAGjB,OAAkB,GAAdsD,GAAiC,GAAdC,EACrB,CAAA,IAEFG,QAAQC,IAAIH,GACZE,QAAQC,IAAI7D,GACZD,KAAKC,cAAgBA,EACrBD,KAAKK,eAAiBA,EACtBL,KAAKY,eAAiBA,EACtBZ,KAAKG,UAAYA,EACjBH,KAAKI,MAAQ,IAGT2D,EAAS/D,KAAKD,OAAOO,aAAa,CACpCC,KAAM,GACNC,MAAOC,eAAeM,SACtBG,kBAAkB,IAEhB8C,EAAUD,EAAO3C,iBACrB,IAAI6C,YAAYD,GAAS3C,IAAI,CAACoC,EAAYC,IAC1C,IAAIQ,aAAaF,GAAS3C,IAAI,CAACrB,KAAKC,cAAe0D,GAAI,GACvDI,EAAOzC,QAEPtB,KAAKa,gBAAkBb,KAAKD,OAAOO,aAAa,CAC9CC,KAAMkD,EAAaA,EAAa,EAChCjD,MAAOC,eAAeC,QAAUD,eAAeM,WAGjDf,KAAKgB,WAAahB,KAAKD,OAAOO,aAAa,CACzCC,KAAyB,GAAlBkD,EAAa,GAAS,GAAK,EAClCjD,MAAOC,eAAeC,QAAUD,eAAeM,WAGjDf,KAAKuB,uBAAyBvB,KAAKD,OAAOO,aAAa,CACrDC,KAAM,EACNC,MAAOC,eAAee,QACtBN,kBAAkB,IAGhBiD,EAAcnE,KAAKuB,uBAAuBH,iBAC9C,IAAIgD,WAAWD,GAAa9C,IAAI,CAACoC,IACjC,IAAIS,aAAaC,GAAa9C,IAAI,CAAC,IAAM,IAErCgD,EAAiBrE,KAAKD,OAAOuE,wBAClBC,mBAAmBR,EAAQ,EAAG/D,KAAKsD,aAAc,EAAG,IAC/DkB,EAAkBxE,KAAKD,OAAOyE,gBAAgB,CAChD1B,OAAQ9C,KAAKyB,wBAAwBgD,mBAAmB,GACxDtC,QAAS,CACP,CACEC,QAAS,EACTsC,SAAU,CACRlC,OAAQxC,KAAKY,iBAGjB,CACEwB,QAAS,EACTsC,SAAU,CACRlC,OAAQxC,KAAKa,kBAGjB,CACEuB,QAAS,EACTsC,SAAU,CACRlC,OAAQxC,KAAKsD,mBAKjBqB,EAAON,EAAeO,oBACrBC,aAAa,EAAGL,GACrBG,EAAKG,YAAY9E,KAAKyB,yBACtBkD,EAAKI,SAAS,EAAG,EAAG,GACpBJ,EAAKK,UAcLhF,KAAKD,OAAOkF,MAAMC,OAAO,CAACb,EAAec,WAezCnF,KAAKc,gBAAkBd,KAAKD,OAAOO,aAAa,CAC9CC,KAAmB,EAAbkD,EAAiB,EACvBjD,MAAOC,eAAeC,QAAUD,eAAeM,WAG7CqE,EAAgC,GAChCC,EAAaC,YAAYC,MACzBC,EAAiBxF,KAAKD,OAAOyE,gBAAgB,CAC/C1B,OAAQ9C,KAAKoD,oBAAoBqB,mBAAmB,GACpDtC,QAAS,CACP,CACEC,QAAS,EACTsC,SAAU,CACRlC,OAAQxC,KAAKK,iBAGjB,CACE+B,QAAS,EACTsC,SAAU,CACRlC,OAAQxC,KAAKc,qBAMf2E,EAAgBzF,KAAKD,OAAOyE,gBAAgB,CAChD1B,OAAQ9C,KAAKiC,oBACbE,QAAS,CACP,CACEC,QAAS,EACTsC,SAAU,CAAElC,OAAQxC,KAAKK,iBAG3B,CACE+B,QAAS,EACTsC,SAAU,CAAElC,OAAQxC,KAAKgB,aAG3B,CACEoB,QAAS,EACTsC,SAAU,CAAElC,OAAQxC,KAAKuB,yBAE3B,CACEa,QAAS,EACTsC,SAAU,CAAElC,OAAQxC,KAAKiB,sBAK3ByE,EAAkBrB,EAAeO,oBACrBE,YAAY9E,KAAK6C,qBACjC6C,EAAgBb,aAAa,EAAGY,GAChCC,EAAgBX,SAAStB,EAAY,EAAG,GACxCiC,EAAgBV,UAEZW,EAAoB3F,KAAKD,OAAOO,aAAa,CAC/CC,KAAyB,GAAlBkD,EAAa,GAAS,GAAK,EAClCjD,MAAOC,eAAeE,SAAWF,eAAemF,WAElDvB,EAAeE,mBACbvE,KAAKgB,WACL,EACA2E,EACA,EACa,EAAblC,GAGF,CAAA,EAAMkC,EAAkBE,SAASC,WAAWC,eAA5CC,EAAAC,OACMC,EAAcP,EAAkBvE,iBAClC+E,EAAa,IAAIjC,aAAagC,GAClCP,EAAkBrE,QAClBuC,QAAQC,IAAIqC,2BAGO,EAAjBjG,GACqB,KAArBF,KAAKC,eACS,GAAdD,KAAKI,OAELF,IAEI6D,EAAS/D,KAAKD,OAAOO,aAAa,CACpCC,KAAM,GACNC,MAAOC,eAAeM,SACtBG,kBAAkB,IAEhB8C,EAAUD,EAAO3C,iBACrB,IAAI6C,YAAYD,GAAS3C,IAAI,CAACoC,EAAYC,IAC1C,IAAIQ,aAAaF,GAAS3C,IAAI,CAACrB,KAAKC,cAAe0D,GAAI,GACvDI,EAAOzC,SAEH+C,EAAiBrE,KAAKD,OAAOuE,wBAElBC,mBAAmBR,EAAQ,EAAG/D,KAAKsD,aAAc,EAAG,IAG/D8C,EAAYpG,KAAKD,OAAOyE,gBAAgB,CAC1C1B,OAAQ9C,KAAKgD,sBAAsByB,mBAAmB,GACtDtC,QAAS,CACP,CACEC,QAAS,EACTsC,SAAU,CACRlC,OAAQxC,KAAKK,iBAGjB,CACE+B,QAAS,EACTsC,SAAU,CACRlC,OAAQxC,KAAKa,kBAGjB,CACEuB,QAAS,EACTsC,SAAU,CACRlC,OAAQxC,KAAKc,kBAGjB,CACEsB,QAAS,EACTsC,SAAU,CACRlC,OAAQxC,KAAKsD,kBAMEtD,KAAKD,OAAOyE,gBAAgB,CACjD1B,OAAQ9C,KAAKkD,6BAA6BuB,mBAAmB,GAC7DtC,QAAS,CACP,CACEC,QAAS,EACTsC,SAAU,CACRlC,OAAQxC,KAAKK,iBAGjB,CACE+B,QAAS,EACTsC,SAAU,CACRlC,OAAQxC,KAAKY,iBAGjB,CACEwB,QAAS,EACTsC,SAAU,CACRlC,OAAQxC,KAAKc,kBAGjB,CACEsB,QAAS,EACTsC,SAAU,CACRlC,OAAQxC,KAAKsD,mBA0BjBqB,EAAON,EAAeO,oBACrBC,aAAa,EAAGuB,GACrBzB,EAAKG,YAAY9E,KAAKgD,uBACtB2B,EAAKI,SAAStB,EAAY,EAAG,GAC7BkB,EAAKK,WAuBDL,EAAON,EAAeO,oBAKrBC,aAAa,EAAGW,GACrBb,EAAKG,YAAY9E,KAAKoD,qBACtBuB,EAAKI,SAAStB,EAAY,EAAG,GAC7BkB,EAAKK,UAELhF,KAAKD,OAAOkF,MAAMC,OAAO,CAACb,EAAec,WACrCkB,EAAgBf,YAAYC,MAChC,CAAA,EAAMvF,KAAKD,OAAOkF,MAAMqB,wBA1IT,CAAA,EAAA,iBA0IfN,EAAAC,OACIM,EAAcjB,YAAYC,MAC9B1B,QAAQC,IAAI,mBAAkByC,EAAMF,IACpCjB,EAAeoB,KAAKD,EAAMF,GAQ1BrG,KAAKC,cAAgBD,KAAKC,cAAgBA,sBAExCwG,EAAWnB,YAAYC,MACvBmB,EACFtB,EAAeuB,OAAO,SAAUC,EAAGC,GACjC,OAAOD,EAAIC,IACRzB,EAAe0B,OACtBlD,EAAQmD,QAASC,UAAY,gBAC3B5B,EAAe0B,OAAM,gCAErBL,EAAWpB,GAAU,+BACQqB,YAEnC5G,EAliBA,GAoiBAmH,QAAA,QAAenH","file":"force_directed.min.js","sourcesContent":["import { buffer } from \"d3\";\r\nimport { size } from \"mathjs\";\r\nimport {\r\n  compute_forces,\r\n  apply_forces,\r\n  compute_forces_a,\r\n  create_adjacency_matrix,\r\n  compute_forces_combined,\r\n  buildTree,\r\n} from \"./wgsl\";\r\n\r\nclass ForceDirected {\r\n  public paramsBuffer: GPUBuffer;\r\n  public nodeDataBuffer: GPUBuffer;\r\n  public edgeDataBuffer: GPUBuffer;\r\n  public adjMatrixBuffer: GPUBuffer;\r\n  public forceDataBuffer: GPUBuffer;\r\n  public treeBuffer: GPUBuffer;\r\n  public lastIndexBuffer: GPUBuffer;\r\n  public uniformParameterBuffer: GPUBuffer;\r\n  public coolingFactor: number = 0.9;\r\n  public device: GPUDevice;\r\n\r\n  public bindGroupLayoutTree: GPUBindGroupLayout;\r\n  public treePipelineLayout: GPUPipelineLayout;\r\n\r\n  public computeTreePipeline: GPUComputePipeline;\r\n\r\n  public createAdjMatrixPipeline: GPUComputePipeline;\r\n  public computeForcesPipeline: GPUComputePipeline;\r\n  public computeAttractForcesPipeline: GPUComputePipeline;\r\n  public applyForcesPipeline: GPUComputePipeline;\r\n  public iterationCount: number = 10000;\r\n  public threshold: number = 100;\r\n  public force: number = 1000.0;\r\n\r\n  constructor(device: GPUDevice) {\r\n    this.device = device;\r\n\r\n    this.nodeDataBuffer = this.device.createBuffer({\r\n      size: 16,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    });\r\n\r\n    this.edgeDataBuffer = this.device.createBuffer({\r\n      size: 16,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    });\r\n\r\n    this.adjMatrixBuffer = this.device.createBuffer({\r\n      size: 16,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    });\r\n\r\n    this.forceDataBuffer = this.device.createBuffer({\r\n      size: 16,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n\r\n    this.treeBuffer = this.device.createBuffer({\r\n      size: 16,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n\r\n    this.lastIndexBuffer = this.device.createBuffer({\r\n      size: 4,\r\n      mappedAtCreation: true,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n\r\n    new Int32Array(this.lastIndexBuffer.getMappedRange()).set([0]);\r\n    this.lastIndexBuffer.unmap();\r\n\r\n    this.uniformParameterBuffer = this.device.createBuffer({\r\n      size: 16,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n\r\n    this.createAdjMatrixPipeline = device.createComputePipeline({\r\n      compute: {\r\n        module: device.createShaderModule({\r\n          code: create_adjacency_matrix,\r\n        }),\r\n        entryPoint: \"main\",\r\n      },\r\n    });\r\n\r\n    this.bindGroupLayoutTree = device.createBindGroupLayout({\r\n      entries: [\r\n        {\r\n          //node\r\n          binding: 0,\r\n          visibility: GPUShaderStage.COMPUTE,\r\n          buffer: {\r\n            type: \"read-only-storage\" as GPUBufferBindingType,\r\n          },\r\n        },\r\n        {\r\n          //tree\r\n          binding: 1,\r\n          visibility: GPUShaderStage.COMPUTE,\r\n          buffer: {\r\n            type: \"storage\" as GPUBufferBindingType,\r\n          },\r\n        },\r\n        {\r\n          //uniform parameter\r\n          binding: 2,\r\n          visibility: GPUShaderStage.COMPUTE,\r\n          buffer: {\r\n            type: \"uniform\" as GPUBufferBindingType,\r\n          },\r\n        },\r\n\r\n        {\r\n          binding: 3,\r\n          visibility: GPUShaderStage.COMPUTE,\r\n          buffer: {\r\n            type: \"storage\" as GPUBufferBindingType,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n\r\n    this.treePipelineLayout = this.device.createPipelineLayout({\r\n      bindGroupLayouts: [this.bindGroupLayoutTree],\r\n    });\r\n\r\n    this.computeTreePipeline = device.createComputePipeline({\r\n      layout: this.treePipelineLayout,\r\n      compute: {\r\n        module: device.createShaderModule({\r\n          code: buildTree,\r\n        }),\r\n        entryPoint: \"main\",\r\n      },\r\n    });\r\n\r\n    this.computeForcesPipeline = device.createComputePipeline({\r\n      compute: {\r\n        module: device.createShaderModule({\r\n          code: compute_forces_combined,\r\n        }),\r\n        entryPoint: \"main\",\r\n      },\r\n    });\r\n\r\n    this.computeAttractForcesPipeline = device.createComputePipeline({\r\n      compute: {\r\n        module: device.createShaderModule({\r\n          code: compute_forces_a,\r\n        }),\r\n        entryPoint: \"main\",\r\n      },\r\n      layout: device.createPipelineLayout({\r\n        bindGroupLayouts: [\r\n          device.createBindGroupLayout({\r\n            entries: [\r\n              {\r\n                binding: 0,\r\n                visibility: GPUShaderStage.COMPUTE,\r\n                buffer: {\r\n                  type: \"read-only-storage\" as GPUBufferBindingType,\r\n                },\r\n              },\r\n              {\r\n                binding: 1,\r\n                visibility: GPUShaderStage.COMPUTE,\r\n                buffer: {\r\n                  type: \"read-only-storage\" as GPUBufferBindingType,\r\n                },\r\n              },\r\n              {\r\n                binding: 2,\r\n                visibility: GPUShaderStage.COMPUTE,\r\n                buffer: {\r\n                  type: \"storage\" as GPUBufferBindingType,\r\n                },\r\n              },\r\n              {\r\n                binding: 3,\r\n                visibility: GPUShaderStage.COMPUTE,\r\n                buffer: {\r\n                  type: \"uniform\" as GPUBufferBindingType,\r\n                },\r\n              },\r\n            ],\r\n          }),\r\n        ],\r\n      }),\r\n    });\r\n\r\n    this.applyForcesPipeline = device.createComputePipeline({\r\n      compute: {\r\n        module: device.createShaderModule({\r\n          code: apply_forces,\r\n        }),\r\n        entryPoint: \"main\",\r\n      },\r\n    });\r\n\r\n    // Create a buffer to store the params, output, and min/max\r\n    this.paramsBuffer = device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n  }\r\n\r\n  async runForces(\r\n    nodeDataBuffer = this.nodeDataBuffer,\r\n    edgeDataBuffer = this.edgeDataBuffer,\r\n    nodeLength: number = 0,\r\n    edgeLength: number = 0,\r\n    coolingFactor = this.coolingFactor,\r\n    l = 0.05,\r\n    iterationCount = this.iterationCount,\r\n    threshold = this.threshold,\r\n    iterRef\r\n  ) {\r\n    if (nodeLength == 0 || edgeLength == 0) {\r\n      return;\r\n    }\r\n    console.log(l);\r\n    console.log(coolingFactor);\r\n    this.coolingFactor = coolingFactor;\r\n    this.nodeDataBuffer = nodeDataBuffer;\r\n    this.edgeDataBuffer = edgeDataBuffer;\r\n    this.threshold = threshold;\r\n    this.force = 100000;\r\n\r\n    // Set up params (node length, edge length) for creating adjacency matrix\r\n    var upload = this.device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.COPY_SRC,\r\n      mappedAtCreation: true,\r\n    });\r\n    var mapping = upload.getMappedRange();\r\n    new Uint32Array(mapping).set([nodeLength, edgeLength]);\r\n    new Float32Array(mapping).set([this.coolingFactor, l], 2);\r\n    upload.unmap();\r\n\r\n    this.adjMatrixBuffer = this.device.createBuffer({\r\n      size: nodeLength * nodeLength * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n\r\n    this.treeBuffer = this.device.createBuffer({\r\n      size: (nodeLength + 1) * 4 * 12 * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n\r\n    this.uniformParameterBuffer = this.device.createBuffer({\r\n      size: 8,\r\n      usage: GPUBufferUsage.UNIFORM,\r\n      mappedAtCreation: true,\r\n    });\r\n\r\n    let arrInstance = this.uniformParameterBuffer.getMappedRange();\r\n    new Uint8Array(arrInstance).set([nodeLength]);\r\n    new Float32Array(arrInstance).set([0.5], 1);\r\n\r\n    var commandEncoder = this.device.createCommandEncoder();\r\n    commandEncoder.copyBufferToBuffer(upload, 0, this.paramsBuffer, 0, 4 * 4);\r\n    var createBindGroup = this.device.createBindGroup({\r\n      layout: this.createAdjMatrixPipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.edgeDataBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.adjMatrixBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.paramsBuffer,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    var pass = commandEncoder.beginComputePass();\r\n    pass.setBindGroup(0, createBindGroup);\r\n    pass.setPipeline(this.createAdjMatrixPipeline);\r\n    pass.dispatch(1, 1, 1);\r\n    pass.endPass();\r\n    // Log adjacency matrix\r\n    // const gpuReadBuffer = this.device.createBuffer({\r\n    //     size: nodeLength * nodeLength * 4,\r\n    //     usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\r\n    // });\r\n    // // Encode commands for copying buffer to buffer.\r\n    // commandEncoder.copyBufferToBuffer(\r\n    //     this.adjMatrixBuffer /* source buffer */ ,\r\n    //     0 /* source offset */ ,\r\n    //     gpuReadBuffer /* destination buffer */ ,\r\n    //     0 /* destination offset */ ,\r\n    //     nodeLength * nodeLength * 4 /* size */\r\n    // );\r\n    this.device.queue.submit([commandEncoder.finish()]);\r\n\r\n    // Log adjacency matrix (count should be equal to the number of nonduplicate edges)\r\n    // await gpuReadBuffer.mapAsync(GPUMapMode.READ);\r\n    // const arrayBuffer = gpuReadBuffer.getMappedRange();\r\n    // var output = new Uint32Array(arrayBuffer);\r\n    // var count = 0;\r\n    // for (var i = 0; i < output.length; i++) {\r\n    //     if (output[i] == 1) {\r\n    //         count++;\r\n    //     }\r\n    // }\r\n    // console.log(output);\r\n    // console.log(count);\r\n\r\n    this.forceDataBuffer = this.device.createBuffer({\r\n      size: nodeLength * 2 * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n\r\n    var iterationTimes: Array<number> = [];\r\n    var totalStart = performance.now();\r\n    var applyBindGroup = this.device.createBindGroup({\r\n      layout: this.applyForcesPipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.forceDataBuffer,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n\r\n    const bindGroupTree = this.device.createBindGroup({\r\n      layout: this.bindGroupLayoutTree,\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: { buffer: this.nodeDataBuffer },\r\n        },\r\n\r\n        {\r\n          binding: 1,\r\n          resource: { buffer: this.treeBuffer },\r\n        },\r\n\r\n        {\r\n          binding: 2,\r\n          resource: { buffer: this.uniformParameterBuffer },\r\n        },\r\n        {\r\n          binding: 3,\r\n          resource: { buffer: this.lastIndexBuffer },\r\n        },\r\n      ],\r\n    });\r\n\r\n    var treeComputePass = commandEncoder.beginComputePass();\r\n    treeComputePass.setPipeline(this.computeTreePipeline);\r\n    treeComputePass.setBindGroup(0, bindGroupTree);\r\n    treeComputePass.dispatch(nodeLength, 1, 1);\r\n    treeComputePass.endPass();\r\n\r\n    let gpuReadTreeBuffer = this.device.createBuffer({\r\n      size: (nodeLength + 1) * 4 * 12 * 4,\r\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\r\n    });\r\n    commandEncoder.copyBufferToBuffer(\r\n      this.treeBuffer,\r\n      0,\r\n      gpuReadTreeBuffer,\r\n      0,\r\n      nodeLength * 6\r\n    );\r\n    \r\n    await gpuReadTreeBuffer.mapAsync(GPUMapMode.READ);\r\n    const arrayBuffer = gpuReadTreeBuffer.getMappedRange();\r\n    var resultTree = new Float32Array(arrayBuffer);\r\n    gpuReadTreeBuffer.unmap();\r\n    console.log(resultTree);\r\n\r\n    while (\r\n      iterationCount > 0 &&\r\n      this.coolingFactor > 0.000001 &&\r\n      this.force >= 0\r\n    ) {\r\n      iterationCount--;\r\n      // Set up params (node length, edge length)\r\n      var upload = this.device.createBuffer({\r\n        size: 4 * 4,\r\n        usage: GPUBufferUsage.COPY_SRC,\r\n        mappedAtCreation: true,\r\n      });\r\n      var mapping = upload.getMappedRange();\r\n      new Uint32Array(mapping).set([nodeLength, edgeLength]);\r\n      new Float32Array(mapping).set([this.coolingFactor, l], 2);\r\n      upload.unmap();\r\n      //this.device.createQuerySet({})\r\n      var commandEncoder = this.device.createCommandEncoder();\r\n      //commandEncoder.writeTimestamp();\r\n      commandEncoder.copyBufferToBuffer(upload, 0, this.paramsBuffer, 0, 4 * 4);\r\n      // Create bind group\r\n\r\n      var bindGroup = this.device.createBindGroup({\r\n        layout: this.computeForcesPipeline.getBindGroupLayout(0),\r\n        entries: [\r\n          {\r\n            binding: 0,\r\n            resource: {\r\n              buffer: this.nodeDataBuffer,\r\n            },\r\n          },\r\n          {\r\n            binding: 1,\r\n            resource: {\r\n              buffer: this.adjMatrixBuffer,\r\n            },\r\n          },\r\n          {\r\n            binding: 2,\r\n            resource: {\r\n              buffer: this.forceDataBuffer,\r\n            },\r\n          },\r\n          {\r\n            binding: 3,\r\n            resource: {\r\n              buffer: this.paramsBuffer,\r\n            },\r\n          },\r\n        ],\r\n      });\r\n\r\n      var attractBindGroup = this.device.createBindGroup({\r\n        layout: this.computeAttractForcesPipeline.getBindGroupLayout(0),\r\n        entries: [\r\n          {\r\n            binding: 0,\r\n            resource: {\r\n              buffer: this.nodeDataBuffer,\r\n            },\r\n          },\r\n          {\r\n            binding: 1,\r\n            resource: {\r\n              buffer: this.edgeDataBuffer,\r\n            },\r\n          },\r\n          {\r\n            binding: 2,\r\n            resource: {\r\n              buffer: this.forceDataBuffer,\r\n            },\r\n          },\r\n          {\r\n            binding: 3,\r\n            resource: {\r\n              buffer: this.paramsBuffer,\r\n            },\r\n          },\r\n          // {\r\n          //     binding:4,\r\n          //     resource: {\r\n          //         buffer: this.maxForceBuffer\r\n          //     }\r\n          // }\r\n        ],\r\n      });\r\n\r\n      // Run attract forces pass\r\n      // var pass = commandEncoder.beginComputePass();\r\n      // pass.setBindGroup(0, attractBindGroup);\r\n      // pass.setPipeline(this.computeAttractForcesPipeline);\r\n      // pass.dispatch(1, 1, 1);\r\n      // pass.endPass();\r\n      // this.device.queue.submit([commandEncoder.finish()]);\r\n      // var start : number = performance.now();\r\n      // await this.device.queue.onSubmittedWorkDone();\r\n      // var end : number = performance.now();\r\n      // console.log(`attract force time: ${end - start}`)\r\n      // var commandEncoder = this.device.createCommandEncoder();\r\n\r\n      // Run compute forces pass\r\n      var pass = commandEncoder.beginComputePass();\r\n      pass.setBindGroup(0, bindGroup);\r\n      pass.setPipeline(this.computeForcesPipeline);\r\n      pass.dispatch(nodeLength, 1, 1);\r\n      pass.endPass();\r\n\r\n      // Testing timing of both passes (comment out when not debugging)\r\n      // pass.endPass();\r\n      // this.device.queue.submit([commandEncoder.finish()]);\r\n      // var start : number = performance.now();\r\n      // await this.device.queue.onSubmittedWorkDone();\r\n      // var end : number = performance.now();\r\n      // console.log(`compute force time: ${end - start}`)\r\n      // var commandEncoder = this.device.createCommandEncoder();\r\n\r\n      // const gpuReadBuffer = this.device.createBuffer({\r\n      //     size: nodeLength * 2 * 4,\r\n      //     usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\r\n      // });\r\n      // // Encode commands for copying buffer to buffer.\r\n      // commandEncoder.copyBufferToBuffer(\r\n      //     this.forceDataBuffer /* source buffer */ ,\r\n      //     0 /* source offset */ ,\r\n      //     gpuReadBuffer /* destination buffer */ ,\r\n      //     0 /* destination offset */ ,\r\n      //     nodeLength * 2 * 4 /* size */\r\n      // );\r\n      var pass = commandEncoder.beginComputePass();\r\n\r\n      //commandEncoder.writeTimestamp();\r\n\r\n      // Run apply forces pass\r\n      pass.setBindGroup(0, applyBindGroup);\r\n      pass.setPipeline(this.applyForcesPipeline);\r\n      pass.dispatch(nodeLength, 1, 1);\r\n      pass.endPass();\r\n\r\n      this.device.queue.submit([commandEncoder.finish()]);\r\n      var start: number = performance.now();\r\n      await this.device.queue.onSubmittedWorkDone();\r\n      var end: number = performance.now();\r\n      console.log(`iteration time ${end - start}`);\r\n      iterationTimes.push(end - start);\r\n\r\n      // this.maxForceResultBuffer.unmap();\r\n      // Read all of the forces applied.\r\n      // await gpuReadBuffer.mapAsync(GPUMapMode.READ);\r\n      // const arrayBuffer = gpuReadBuffer.getMappedRange();\r\n      // var output = new Float32Array(arrayBuffer);\r\n      // console.log(output);\r\n      this.coolingFactor = this.coolingFactor * coolingFactor;\r\n    }\r\n    var totalEnd = performance.now();\r\n    var iterAvg: number =\r\n      iterationTimes.reduce(function (a, b) {\r\n        return a + b;\r\n      }) / iterationTimes.length;\r\n    iterRef.current!.innerText = `Completed in ${\r\n      iterationTimes.length\r\n    } iterations with total time ${\r\n      totalEnd - totalStart\r\n    } and average iteration time ${iterAvg}`;\r\n  }\r\n}\r\n\r\nexport default ForceDirected;\r\n"]}