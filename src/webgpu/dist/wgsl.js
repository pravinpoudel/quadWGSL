"use strict";
exports.__esModule = true;
exports.compute_terrain = "// compute terrain wgsl\nstruct Node {\n    value : f32;\n    x : f32;\n    y : f32;\n    size : f32;\n};\nstruct Nodes {\n    nodes : array<Node>;\n};\nstruct Uniforms {\n  image_width : u32;\n  image_height : u32;\n  nodes_length : u32;\n  width_factor : f32;\n  view_box : vec4<f32>;\n};\nstruct Pixels {\n    pixels : array<f32>;\n};\nstruct Range {\n    x : atomic<i32>;\n    y : atomic<i32>;\n};\n\n[[group(0), binding(0)]] var<storage, read> nodes : Nodes;\n[[group(0), binding(1)]] var<uniform> uniforms : Uniforms;\n[[group(0), binding(2)]] var<storage, write> pixels : Pixels;\n[[group(0), binding(3)]] var<storage, read_write> range : Range;\n\n[[stage(compute), workgroup_size(1, 1, 1)]]\nfn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n    var pixel_index : u32 = global_id.x + global_id.y * uniforms.image_width;\n    var x : f32 = f32(global_id.x) / f32(uniforms.image_width);\n    var y : f32 = f32(global_id.y) / f32(uniforms.image_height);\n    x = x * (uniforms.view_box.z - uniforms.view_box.x) + uniforms.view_box.x;\n    y = y * (uniforms.view_box.w - uniforms.view_box.y) + uniforms.view_box.y;\n    var value : f32 = 0.0;\n\n    for (var i : u32 = 0u; i < uniforms.nodes_length; i = i + 1u) {\n        var sqrDistance : f32 = (x - nodes.nodes[i].x) * (x - nodes.nodes[i].x) + (y - nodes.nodes[i].y) * (y - nodes.nodes[i].y);\n        value = value + nodes.nodes[i].value / (sqrDistance * uniforms.width_factor + 1.0);\n    }\n    value = value * 100.0;\n    atomicMin(&range.x, i32(floor(value)));\n    atomicMax(&range.y, i32(ceil(value)));\n    pixels.pixels[pixel_index] = value;\n}";
exports.normalize_terrain = "// normalize terrain wgsl\nstruct Uniforms {\n  image_width : u32;\n  image_height : u32;\n  nodes_length : u32;\n  width_factor : f32;\n};\nstruct Pixels {\n    pixels : array<f32>;\n};\nstruct Range {\n    x : i32;\n    y : i32;\n};\n\n[[group(0), binding(0)]] var<storage, write> pixels : Pixels;\n[[group(0), binding(1)]] var<uniform> uniforms : Uniforms;\n[[group(0), binding(2)]] var<storage, read_write> range : Range;\n\n[[stage(compute), workgroup_size(1, 1, 1)]]\nfn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n    var pixel_index : u32 = global_id.x + global_id.y * uniforms.image_width;\n    pixels.pixels[pixel_index] = (pixels.pixels[pixel_index] - f32(range.x)) / f32(range.y - range.x);\n}";
exports.display_2d_vert = "// Vertex shader\nstruct VertexOutput {\n  [[builtin(position)]] Position : vec4<f32>;\n  [[location(0)]] fragPosition: vec4<f32>;\n};\n\n[[stage(vertex)]]\nfn main([[location(0)]] position : vec4<f32>)\n     -> VertexOutput {\n    var output : VertexOutput;\n    output.Position = position;\n    output.fragPosition = 0.5 * (position + vec4<f32>(1.0, 1.0, 1.0, 1.0));\n    return output;\n}\n\n\n";
exports.display_2d_frag = "// Fragment shader\nstruct Pixels {\n    pixels : array<f32>;\n};\nstruct Uniforms {\n    peak_value : f32;\n    valley_value : f32;\n};\nstruct Image {\n    width : u32;\n    height : u32;\n};\n\n[[group(0), binding(0)]] var myTexture: texture_2d<f32>;\n[[group(0), binding(1)]] var<storage, read> pixels : Pixels;\n[[group(0), binding(2)]] var<uniform> uniforms : Uniforms;\n[[group(0), binding(3)]] var<uniform> image_size : Image;\n\nfn outside_grid(p : vec2<u32>) -> bool {\n    return any(p == vec2<u32>(u32(0))) || p.x == image_size.width || p.y == image_size.height;\n}\n\n[[stage(fragment)]]\nfn main([[location(0)]] fragPosition: vec4<f32>) -> [[location(0)]] vec4<f32> {\n    var ufragPos : vec4<u32> = vec4<u32>(fragPosition * f32(image_size.width));\n    var pixelIndex : u32 = ufragPos.x + ufragPos.y * image_size.width;\n    var value : f32 = pixels.pixels[pixelIndex];\n    if (!outside_grid(ufragPos.xy)){\n        var neighbor_peaks : vec4<bool> = vec4<bool>(\n            pixels.pixels[pixelIndex - image_size.width] >= uniforms.peak_value ,\n            pixels.pixels[pixelIndex - u32(1)] >= uniforms.peak_value,\n            pixels.pixels[pixelIndex + u32(1)] >= uniforms.peak_value,\n            pixels.pixels[pixelIndex + image_size.width] >= uniforms.peak_value\n        );\n        var neighbor_valleys : vec4<bool> = vec4<bool>(\n            pixels.pixels[pixelIndex - image_size.width] <= uniforms.valley_value,\n            pixels.pixels[pixelIndex - u32(1)] <= uniforms.valley_value,\n            pixels.pixels[pixelIndex + u32(1)] <= uniforms.valley_value,\n            pixels.pixels[pixelIndex + image_size.width] <= uniforms.valley_value\n        ); \n        if (any(neighbor_peaks) && value < uniforms.peak_value) {\n            return vec4<f32>(0.8, 0.5, 0.5, 1.0);\n        }\n        if (any(neighbor_valleys) && value > uniforms.valley_value) {\n            return vec4<f32>(0.5, 0.3, 0.3, 1.0);\n        }\n    }\n    var color : vec4<f32> = textureLoad(myTexture, vec2<i32>(i32(value * 180.0), 1), 0);\n    return color;\n}";
exports.display_3d_vert = "// Vertex shader\nstruct VertexOutput {\n  [[builtin(position)]] Position : vec4<f32>;\n  [[location(0)]] vray_dir: vec3<f32>;\n  [[location(1), interpolate(flat)]] transformed_eye: vec3<f32>;\n};\nstruct Uniforms {\n  proj_view : mat4x4<f32>;\n  eye_pos : vec4<f32>;\n};\n[[group(0), binding(0)]] var<uniform> uniforms : Uniforms;\n\n[[stage(vertex)]]\nfn main([[location(0)]] position : vec3<f32>)\n     -> VertexOutput {\n    var output : VertexOutput;\n    var volume_translation : vec3<f32> = vec3<f32>(-0.5, -0.5, -0.5);\n    output.Position = uniforms.proj_view * vec4<f32>(position + volume_translation, 1.0);\n    output.transformed_eye = uniforms.eye_pos.xyz - volume_translation;\n    output.vray_dir = position - output.transformed_eye;\n    return output;\n}";
exports.display_3d_frag = "// Fragment shader\nstruct Pixels {\n    pixels : array<f32>;\n};\nstruct Image {\n    width : u32;\n    height : u32;\n};\n\n[[group(0), binding(1)]] var colormap: texture_2d<f32>;\n[[group(0), binding(2)]] var<storage, read> pixels : Pixels;\n[[group(0), binding(3)]] var<uniform> image_size : Image;\n\nfn intersect_box(orig : vec3<f32>, dir : vec3<f32>, box_min : vec3<f32>, box_max : vec3<f32>) -> vec2<f32> {\n    let inv_dir : vec3<f32> = 1.0 / dir;\n    let tmin_tmp : vec3<f32> = (box_min - orig) * inv_dir;\n    let tmax_tmp : vec3<f32> = (box_max - orig) * inv_dir;\n    var tmin : vec3<f32> = min(tmin_tmp, tmax_tmp);\n    var tmax : vec3<f32> = max(tmin_tmp, tmax_tmp);\n    var t0 : f32 = max(tmin.x, max(tmin.y, tmin.z));\n    var t1 : f32 = min(tmax.x, min(tmax.y, tmax.z));\n    return vec2<f32>(t0, t1);\n}\n\nfn outside_grid(p : vec3<f32>, volumeDims : vec3<f32>) -> bool {\n    return any(p < vec3<f32>(0.0)) || any(p >= volumeDims);\n}\n\n[[stage(fragment)]]\nfn main(\n  [[location(0)]] vray_dir: vec3<f32>, \n  [[location(1), interpolate(flat)]] transformed_eye : vec3<f32>\n)-> [[location(0)]] vec4<f32> {\n    var ray_dir : vec3<f32> = normalize(vray_dir);\n    var longest_axis : f32 = f32(max(image_size.width, image_size.height));\n    let volume_dims : vec3<f32> = vec3<f32>(f32(image_size.width), f32(image_size.height), f32(longest_axis));\n    let vol_eye : vec3<f32> = transformed_eye * volume_dims;\n    let grid_ray_dir : vec3<f32> = normalize(ray_dir * volume_dims);\n\n    var t_hit : vec2<f32> = intersect_box(vol_eye, grid_ray_dir, vec3<f32>(0.0), volume_dims - 1.0);\n    if (t_hit.x > t_hit.y) { \n        discard;\n    }\n\n    t_hit.x = max(t_hit.x, 0.0);\n\n    var p : vec3<f32> = (vol_eye + t_hit.x * grid_ray_dir);\n    p = clamp(p, vec3<f32>(0.0), volume_dims - 2.0);\n    let inv_grid_ray_dir : vec3<f32> = 1.0 / grid_ray_dir;\n    let start_cell : vec3<f32> = floor(p);\n    let t_max_neg : vec3<f32> = (start_cell - vol_eye) * inv_grid_ray_dir;\n    let t_max_pos : vec3<f32> = (start_cell + 1.0 - vol_eye) * inv_grid_ray_dir;\n    let is_neg_dir : vec3<f32> = vec3<f32>(grid_ray_dir < vec3<f32>(0.0));\n    // Pick between positive/negative t_max based on the ray sign\n    var t_max : vec3<f32> = mix(t_max_pos, t_max_neg, is_neg_dir);\n    let grid_step : vec3<i32> = vec3<i32>(sign(grid_ray_dir));\n    // Note: each voxel is a 1^3 box on the grid\n    let t_delta : vec3<f32> = abs(inv_grid_ray_dir);\n\n    var t_prev : f32 = t_hit.x;\n    // Traverse the grid\n    loop {\n        if (outside_grid(p, volume_dims)) { break; }\n        let v000 : vec3<u32> = vec3<u32>(p);\n        var pixel_index : u32 = v000.x + v000.y * image_size.width;\n        var value : f32 = pixels.pixels[pixel_index];\n        if (f32(v000.z) > longest_axis / 2.0) {\n            if (value * longest_axis >= f32(v000.z)) {\n                return textureLoad(colormap, vec2<i32>(i32(value * 180.0), 1), 0);\n            }\n        } elseif (f32(v000.z) < longest_axis / 2.0) {\n            if (value * longest_axis <= f32(v000.z)) {\n                return textureLoad(colormap, vec2<i32>(i32(value * 180.0), 1), 0);\n            }\n        } else {\n            return textureLoad(colormap, vec2<i32>(i32(value * 180.0), 1), 0);\n        }\n\n        let t_next : f32 = min(t_max.x, min(t_max.y, t_max.z));\n        t_prev = t_next;\n        if (t_next == t_max.x) {\n            p.x = p.x + f32(grid_step.x);\n            t_max.x = t_max.x + t_delta.x;\n        } elseif (t_next == t_max.y) {\n            p.y = p.y + f32(grid_step.y);\n            t_max.y = t_max.y + t_delta.y;\n        } else {\n            p.z = p.z + f32(grid_step.z);\n            t_max.z = t_max.z + t_delta.z;\n        }\n    }\n    return vec4<f32>(0.0, 0.0, 0.0, 0.0);\n}\n\n";
exports.node_vert = "struct Node {\n    value : f32;\n    x : f32;\n    y : f32;\n    size : f32;\n};\nstruct Nodes {\n    nodes : array<Node>;\n};\nstruct VertexOutput {\n    [[builtin(position)]] Position : vec4<f32>;\n    [[location(0)]] position: vec2<f32>;\n    [[location(1), interpolate(flat)]] center : vec2<f32>;\n};\nstruct Uniforms {\n  view_box : vec4<f32>;\n};\nstruct Edges {\n    edges : array<u32>;\n};\n\n[[group(0), binding(0)]] var<uniform> uniforms : Uniforms;\n[[group(0), binding(1)]] var<storage, read> nodes : Nodes;\n\n[[stage(vertex)]]\nfn main([[builtin(instance_index)]] index : u32, [[location(0)]] position : vec2<f32>)\n     -> VertexOutput {\n    var node_center : vec2<f32> = 2.0 * vec2<f32>(nodes.nodes[index].x, nodes.nodes[index].y) - vec2<f32>(1.0);\n    var translation : vec2<f32> = position * 0.01;\n    var out_position : vec2<f32> = node_center + translation;\n    var output : VertexOutput;\n    var inv_zoom : f32 = uniforms.view_box.z - uniforms.view_box.x;\n    var expected_x : f32 = 0.5 * (1.0 - inv_zoom); \n    var expected_y : f32 = 0.5 * (1.0 - inv_zoom);\n    // view_box expected to be between 0 and 1, panning need to be doubled as clip space is (-1, 1)\n    var x : f32 = (out_position.x - 2.0 * (uniforms.view_box.x - expected_x)) / inv_zoom;\n    var y : f32 = (out_position.y - 2.0 * (uniforms.view_box.y - expected_y)) / inv_zoom;\n    output.Position = vec4<f32>(x, y, 0.0, 1.0);\n    output.position = out_position;\n    // flat interpolated position will give bottom right corner, so translate to center\n    output.center = node_center;\n    return output;\n}";
exports.node_frag = "fn sigmoid(x: f32) -> f32 {\n    return 1.0 / (1.0 + exp(-1.0 * x));\n}\n\n[[stage(fragment)]]\nfn main([[location(0)]] position: vec2<f32>, [[location(1), interpolate(flat)]] center: vec2<f32>) -> [[location(0)]] vec4<f32> {\n    if (distance(position, center) > 0.005) {\n        discard;\n    }\n    return vec4<f32>(0.0, 0.0, 0.0, 1.0 - sigmoid(16.0 * distance(position, center) * 200.0 - 12.0));\n}\n";
exports.edge_vert = "//this builtin(position) clip_position tells that clip_position is the value we want to use for our vertex position or clip position\n//it's not needed to create a struct, we could just do [[builtin(position)]] clipPosition\nstruct VertexOutput{\n    [[builtin(position)]] clip_position: vec4<f32>;\n};\nstruct Uniforms {\n  view_box : vec4<f32>;\n};\nstruct Node {\n    value : f32;\n    x : f32;\n    y : f32;\n    size : f32;\n};\nstruct Nodes {\n    nodes : array<Node>;\n};\n// struct Edge {\n//     source: u32;\n//     target: u32;\n//     padding1: u32;\n//     padding2: u32;\n// };\nstruct Edges {\n    edges : array<u32>;\n};\n\n[[group(0), binding(0)]] var<uniform> uniforms : Uniforms;\n[[group(0), binding(1)]] var<storage, read> nodes : Nodes;\n[[group(0), binding(2)]] var<storage, read> edges : Edges;\n[[stage(vertex)]]\nfn main([[builtin(instance_index)]] index : u32, [[location(0)]] position: vec2<f32>)-> VertexOutput {\n    var out : VertexOutput;\n    var node : Node = nodes.nodes[edges.edges[index + u32(position.x)]];\n    var inv_zoom : f32 = uniforms.view_box.z - uniforms.view_box.x;\n    var expected_x : f32 = 0.5 * (1.0 - inv_zoom); \n    var expected_y : f32 = 0.5 * (1.0 - inv_zoom);\n    // view_box expected to be between 0 and 1, panning need to be doubled as clip space is (-1, 1)\n    var x : f32 = ((2.0 * node.x - 1.0) - 2.0 * (uniforms.view_box.x - expected_x)) / inv_zoom;\n    var y : f32 = ((2.0 * node.y - 1.0) - 2.0 * (uniforms.view_box.y - expected_y)) / inv_zoom;\n    out.clip_position = vec4<f32>(x, y, 0.0, 1.0);\n    return out;\n}";
exports.edge_frag = "[[stage(fragment)]]\nfn main()->[[location(0)]] vec4<f32>{\n    return vec4<f32>(0.0, 0.0, 0.0, 0.02);\n}";
exports.compute_forces = "struct Node {\n    value : f32;\n    x : f32;\n    y : f32;\n    size : f32;\n};\nstruct Nodes {\n    nodes : array<Node>;\n};\nstruct Edges {\n    edges : array<u32>;\n};\nstruct Forces {\n    forces : array<f32>;\n};\nstruct Uniforms {\n    nodes_length : u32;\n    edges_length : u32;\n    cooling_factor : f32;\n    ideal_length : f32;\n};\n\n// struct maxForceScalar{\n//     maxforceScalar: atomic<i32>;\n// };\n\n[[group(0), binding(0)]] var<storage, read> nodes : Nodes;\n[[group(0), binding(1)]] var<storage, read_write> forces : Forces;\n[[group(0), binding(2)]] var<uniform> uniforms : Uniforms;\n// [[group(0), binding(4)]] var<storage, read_write> maxforce: maxForceScalar; \n\n[[stage(compute), workgroup_size(1, 1, 1)]]\nfn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n    let l : f32 = uniforms.ideal_length;\n    let node : Node = nodes.nodes[global_id.x];\n    var r_force : vec2<f32> = vec2<f32>(0.0, 0.0);\n    for (var i : u32 = 0u; i < uniforms.nodes_length; i = i + 1u) {\n        if (i == global_id.x) {\n            continue;\n        }\n        var node2 : Node = nodes.nodes[i];\n        var dist : f32 = distance(vec2<f32>(node.x, node.y), vec2<f32>(node2.x, node2.y));\n        if(dist>0.0){\n            var dir : vec2<f32> = normalize(vec2<f32>(node.x, node.y) - vec2<f32>(node2.x, node2.y));\n            r_force = r_force + ((l * l) / dist) * dir;\n        }\n\n    }\n    var a_force : vec2<f32> = vec2<f32>(forces.forces[global_id.x * 2u], forces.forces[global_id.x * 2u + 1u]);\n    // var a_force : vec2<f32> = vec2<f32>(0.0, 0.0);\n    var force : vec2<f32> = (a_force + r_force);\n    var localForceMag: f32 = length(force); \n    if(localForceMag>0.000000001){\n        force = normalize(force)* min(uniforms.cooling_factor, length(force));\n    }\n    else{\n        force.x = 0.0;\n        force.y = 0.0;\n    }\n    forces.forces[global_id.x * 2u] = force.x;\n    forces.forces[global_id.x * 2u + 1u] = force.y;\n    // atomicMax(&maxforce.maxforceScalar, i32(floor(localForceMag*1000.0)));\n}\n";
exports.compute_forces_a = "struct Node {\n    value : f32;\n    x : f32;\n    y : f32;\n    size : f32;\n};\nstruct Nodes {\n    nodes : array<Node>;\n};\nstruct Edges {\n    edges : array<u32>;\n};\nstruct Forces {\n    forces : array<f32>;\n};\nstruct Uniforms {\n    nodes_length : u32;\n    edges_length : u32;\n    cooling_factor : f32;\n    ideal_length : f32;\n};\n\n[[group(0), binding(0)]] var<storage, read> nodes : Nodes;\n[[group(0), binding(1)]] var<storage, read> edges : Edges;\n[[group(0), binding(2)]] var<storage, read_write> forces : Forces;\n[[group(0), binding(3)]] var<uniform> uniforms : Uniforms;\n\n[[stage(compute), workgroup_size(1, 1, 1)]]\nfn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n    let l : f32 = uniforms.ideal_length;\n    var a_force : vec2<f32> = vec2<f32>(0.0, 0.0);\n    for (var i : u32 = 0u; i < uniforms.edges_length; i = i + 2u) {\n        var node : Node = nodes.nodes[edges.edges[i]];\n        var node2 : Node = nodes.nodes[edges.edges[i + 1u]];\n        var dist : f32 = distance(vec2<f32>(node.x, node.y), vec2<f32>(node2.x, node2.y));\n        if(dist > 0.0) {\n            var dir : vec2<f32> = normalize(vec2<f32>(node2.x, node2.y) - vec2<f32>(node.x, node.y));\n            a_force = ((dist * dist) / l) * dir;\n            forces.forces[edges.edges[i] * 2u] = forces.forces[edges.edges[i] * 2u] + a_force.x;\n            forces.forces[edges.edges[i] * 2u + 1u] = forces.forces[edges.edges[i] * 2u + 1u] + a_force.y;\n            forces.forces[edges.edges[i + 1u] * 2u] = forces.forces[edges.edges[i + 1u] * 2u] - a_force.x;\n            forces.forces[edges.edges[i + 1u] * 2u + 1u] = forces.forces[edges.edges[i + 1u] * 2u + 1u] - a_force.y;\n        }\n    } \n}\n";
exports.apply_forces = "struct Node {\n    value : f32;\n    x : f32;\n    y : f32;\n    size : f32;\n};\nstruct Nodes {\n    nodes : array<Node>;\n};\nstruct Forces {\n    forces : array<f32>;\n};\n\n[[group(0), binding(0)]] var<storage, read_write> nodes : Nodes;\n[[group(0), binding(1)]] var<storage, read_write> forces : Forces;\n[[stage(compute), workgroup_size(1, 1, 1)]]\nfn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n    nodes.nodes[global_id.x].x = nodes.nodes[global_id.x].x + forces.forces[global_id.x * 2u];\n    nodes.nodes[global_id.x].y = nodes.nodes[global_id.x].y + forces.forces[global_id.x * 2u + 1u]; \n    forces.forces[global_id.x * 2u] = 0.0;\n    forces.forces[global_id.x * 2u + 1u] = 0.0;\n    // nodes.nodes[global_id.x].x = min(1.0, max(-1.0, nodes.nodes[global_id.x].x));\n    // nodes.nodes[global_id.x].y = min(1.0, max(-1.0, nodes.nodes[global_id.x].y));\n    // nodes.nodes[global_id.x].x = nodes.nodes[global_id.x].x + 0.01;\n    // nodes.nodes[global_id.x].y = nodes.nodes[global_id.x].y + 0.01;\n    // var test : f32 = forces.forces[0]; \n    // var test2 : f32 = nodes.nodes[0].x;\n}\n";
exports.create_adjacency_matrix = "struct Edges {\n    edges : array<u32>;\n};\nstruct BoolArray {\n    matrix : array<u32>;\n};\nstruct Uniforms {\n    nodes_length : u32;\n    edges_length : u32;\n    cooling_factor : f32;\n    ideal_length : f32;\n};\n\n[[group(0), binding(0)]] var<storage, read> edges : Edges;\n[[group(0), binding(1)]] var<storage, read_write> adjmat : BoolArray;\n[[group(0), binding(2)]] var<uniform> uniforms : Uniforms;\n\n[[stage(compute), workgroup_size(1, 1, 1)]]\nfn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n    for (var i : u32 = 0u; i < uniforms.edges_length; i = i + 2u) {\n        var source : u32 = edges.edges[i];\n        var target : u32 = edges.edges[i + 1u];\n        adjmat.matrix[source * uniforms.nodes_length + target] = 1u;\n        adjmat.matrix[target * uniforms.nodes_length + source] = 1u;\n    } \n}\n";
exports.compute_forces_combined = "struct Node {\n    value : f32;\n    x : f32;\n    y : f32;\n    size : f32;\n};\nstruct Nodes {\n    nodes : array<Node>;\n};\nstruct Edges {\n    edges : array<u32>;\n};\nstruct Forces {\n    forces : array<f32>;\n};\nstruct Uniforms {\n    nodes_length : u32;\n    edges_length : u32;\n    cooling_factor : f32;\n    ideal_length : f32;\n};\n\n[[group(0), binding(0)]] var<storage, read> nodes : Nodes;\n[[group(0), binding(1)]] var<storage, read> adjmat : Edges;\n[[group(0), binding(2)]] var<storage, read_write> forces : Forces;\n[[group(0), binding(3)]] var<uniform> uniforms : Uniforms;\n\n[[stage(compute), workgroup_size(1, 1, 1)]]\nfn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n    let l : f32 = uniforms.ideal_length;\n    let node : Node = nodes.nodes[global_id.x];\n    var r_force : vec2<f32> = vec2<f32>(0.0, 0.0);\n    var a_force : vec2<f32> = vec2<f32>(0.0, 0.0);\n    for (var i : u32 = 0u; i < uniforms.nodes_length; i = i + 1u) {\n        if (i == global_id.x) {\n            continue;\n        }\n        var node2 : Node = nodes.nodes[i];\n        var dist : f32 = distance(vec2<f32>(node.x, node.y), vec2<f32>(node2.x, node2.y));\n        if (dist > 0.0){\n            if (adjmat.edges[i * uniforms.nodes_length + global_id.x] == 1u) {\n                var dir : vec2<f32> = normalize(vec2<f32>(node2.x, node2.y) - vec2<f32>(node.x, node.y));\n                a_force = a_force + ((dist * dist) / l) * dir;\n            } else {\n                var dir : vec2<f32> = normalize(vec2<f32>(node.x, node.y) - vec2<f32>(node2.x, node2.y));\n                r_force = r_force + ((l * l) / dist) * dir;\n            }\n        }\n\n    }\n    var force : vec2<f32> = (a_force + r_force);\n    var localForceMag: f32 = length(force); \n    if(localForceMag>0.000000001){\n        force = normalize(force)* min(uniforms.cooling_factor, length(force));\n    }\n    else{\n        force.x = 0.0;\n        force.y = 0.0;\n    }\n    forces.forces[global_id.x * 2u] = force.x;\n    forces.forces[global_id.x * 2u + 1u] = force.y;\n}\n";
exports.buildTree = "struct Node{\n    value:f32;\n    x: f32;\n    y: f32;\n    size:f32;\n}\n\nstruct Boundary{\n    x: f32;\n    y: f32;\n    w: f32;\n    h: f32\n}\n\nstruct Position{\n    x:f32;\n    y: f32\n}\n\n//make a default value in this\nstruct Quadtree{\n    boundary: Boundary;\n    CoM: Position;\n    mass: u32;\n    NE: u32;\n    NW: u32;\n    SE: u32;\n    SW: u32;\n    isDivided: bool;\n}\n\nstruct Nodes{\n  nodes: array<Node>;\n};\n\nstruct Tree{\n    quad: array<Quadtree>\n}\n\nstruct uniforms{\n  nodes_length:u32;\n  theta: f32;\n}\n\n[[group(0), binding(0)]] var<storage, read> nodes:Nodes;\n[[group(0), binding(1)]] var<storage> tree:Tree;\n[[group(0), binding(1)]] var<uniform> uniforms:uniforms;\n\nfunction partition(quadtree:Quadtree)-> array<Quadtree>{\n    var child:array<Quadtree>;\n\n    let x:f32 = quadtree.boundary.x;\n    let y:f32 = quadtree.boundary.y;\n    let w:f32 = quadtree.boundary.w;\n    let h:f32 = quadtree.boundary.h;\n\n    let MASS:u32 = 0;\n    let COM:Position = Position(0.0f, 0.0f);\n    let ISDIVIDED:bool = false;\n\n    let NE:u32 = 0;\n    let NW:u32 = 0;\n    let SE:U32 = 0;\n    let SW:u32 = 0;\n\n    let SE_BOUNDARY = Boundary(x+(w/2), y+(h/2), w/2, w/2);\n    let SW_BOUNDARY = Boundary(x-(w/2), y+(h/2), w/2, w/2);\n    let NE_BOUNDARY = Boundary(x+(w/2), y-(h/2), w/2, w/2);\n    let NW_BOUNDARY = Boundary(x-(w/2), y+(h/2), w/2, w/2);\n    \n    var SE: Quadtree = Quadtree(SE_BOUNDARY, COM, MASS, NE, NW, SE, SW, ISDIVIDED);\n    child[0] = SE;    \n    var SW: Quadtree = Quadtree(SW_BOUNDARY, COM, MASS, NE, NW, SE, SW, ISDIVIDED);\n    child[1] = SW;\n    var NE: Quadtree = Quadtree(NE_BOUNDARY, COM, MASS, NE, NW, SE, SW, ISDIVIDED);\n    child[2] = NE;\n    var NW: Quadtree = Quadtree(NW_BOUNDARY, COM, MASS, NE, NW, SE, SW, ISDIVIDED);\n    child[3] = NW;\n    return child;\n}\n\n\nfn isBounded( boundary: Boundary, node: Node)->bool{\n    if (boundary.x + boundary.w == 1.0) {\n      return (\n        node.x >= boundary.x - boundary.w &&\n        node.x <= boundary.x + boundary.w &&\n        node.y >= boundary.y - boundary.h &&\n        node.y < boundary.y + boundary.h\n      );\n    }\n\n    if (boundary.y + boundary.h == 1.0) {\n      return (\n        node.x >= boundary.x - boundary.w &&\n        node.x < boundary.x + boundary.w &&\n        node.y >= boundary.y - boundary.h &&\n        node.y <= boundary.y + boundary.h\n      );\n    } else {\n      return (\n        node.x >= boundary.x - boundary.w &&\n        node.x < boundary.x + boundary.w &&\n        node.y >= boundary.y - boundary.h &&\n        node.y < boundary.y + boundary.h\n      );\n    }\n  }\n\n// check that quadtree in the main quadtree array\n\n  fn insert(node:Node, index:u32)-> bool{\n      \n    if(!isBounded(Tree.quad[index].boundary, node)){\n          return false;\n      }\n\n    if(Tree.quad[index].mass<1){\n          quadtree.mass++;\n          quadtree.CoM.x = node.x;\n          quadtree.CoM.y = node.y;\n          return true;\n      }\n    \n    if(!Tree.quad[index].isDivided && Tree.quad[index].mass>0){\n         //remove node data at that node\n        let nodePosition:Position = tree.quad[index].CoM;\n        let removingNode:Node = Node(0f, nodePosition.x, nodePosition.y, 1.0f); \n        //create a quad\n        let quad:array<Quadtree> = partition(Tree.quad[index]);\n        let SE:Quadtree = quad[0];\n        let SW:Quadtree = quad[1];\n        let NE:Quadtree = quad[2];\n        let NW:Quadtree = quad[3];\n\n        //add that point to tree\n        let treeLength = arrayLength(Tree.quad);\n        Tree.quad[treeLength] = SE;\n        Tree.quad[treeLength+1] = SW;\n        Tree.quad[treeLength+2] = NE;\n        Tree.quad[treeLength+3] = NW;\n        \n        Tree.quad[index].SE = treelength; \n        Tree.quad[index].SW = treelength+1;\n        Tree.quad[index].NE = treelength+2;\n        Tree.quad[index].NW = treelength+3;\n\n        //check where does it exist among four\n        insert(removingNode, treeLength-1)||\n        insert(removingNode, treeLength) ||\n        insert(removingNode, treeLength+1) ||\n        insert(removingNode, treeLength+2)\n         //add new point to tree \n     }\n\n    let totalX:f32 = Tree.quad[index].CoM.x*Tree.quad[index].mass + node.x;\n    let totalY:f32 = Tree.quad[index].CoM.y*Tree.quad[index].mass + node.y;\n\n    Tree.quad[index].mass += 1;\n\n    Tree.quad[index].CoM.x = totalX/Tree.quad[index].mass;\n    Tree.quad[index].CoM.y = totalY/Tree.quad[index].mass;\n       \n    return (\n        insert(node, Tree.quad[index].SE)||\n        insert(node, Tree.quad[index].SW) ||\n        insert(node, Tree.quad[index].NE) ||\n        insert(node, Tree.quad[index].NW)\n    );\n }\n\n  //writing 0f in child quad because it doesnot matter what they are when isDivided is false\n  var coverQuad:Quadtree = Quadtree(Boundary(0f, 0f, 0f, 1f), Postition(0f, 0f), 0f, 0f, 0f, 0f, 0f, false);\n  Tree.quad[0] = coverQuad;\n\n[[stage(compute), workgroup_size(1,1,1)]]\nfn main([[builtin(global_invocation_id)]] global_id: vec3<u32>){\n  let nodes_length:u32 = uniforms.nodes_length;\n  let theta:f32 = uniforms.theta;\n  if(global_id.x>=u32(uniforms.nodes_length)){\n    return;\n  }\n  let node:Node = nodes.nodes[global_id.x];\n  insert(node, 0f);\n}";

//# sourceMappingURL=wgsl.js.map
